<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

# Chinese-Checkers中国跳棋

A simple demo of Chinese checkers with AI.

一个简单的中国跳棋人工智能。

## 项目结构

- package ai
	- Evaluator.java			估值器（接口）
	- MyEvaluator.java			实现的估值器
	- SimpleDeepSearch.java		简单的（近似暴力的）搜索
- package control
	- Actioner.java				前端与后台的中介
- package entity
	- Action.java				一次跳动
	- ChessBoard.java			棋局状态
	- ChessState.java			棋面状态
	- Player.java				玩家
	- Position.java				位置表示
	- Rule.java					规则
- package present
	- Test.java					本来应该写前台的，但是先写了个测试（逃
		

## AI部分介绍

### 概述

棋类游戏还是属于典型的对抗搜索。但是跳棋这个游戏与一般的对抗搜索棋类不同，主要体现在：

1. 玩家需要达成的目标与对手状态无关，只需要自行到达对面即可
2. 游戏的前期与后期几乎不予对手接触，仅在中期需要互相接触
3. 优势条件往往互相获利，即很少需要有意破坏对方的优势条件

因此整体而言，跳棋更像一个非对抗类的游戏，而更类似于竞速类游戏。

为适应这一条件，这里将估值函数独立于每一个玩家，同时使得估值函数的结果仅和自己的棋子有关。尽管一定程度上存在不合理之处，但是仍不失为一个较好的方法。

由于估值函数值彼此独立，对于一般搜索的Alpha-Beta剪枝算法这里也不再适用，取而代之的是常规搜索算法。

### 估值函数的构成

评分由三部分构成：

1. 距离得分，根据所前进的目标方向确定
2. 偏移得分，偏移中心线应酌情扣分
3. 末子罚分，最后的棋子将会受到一定扣分

### 搜索算法

这里采用特定深度的搜索进行，搜索深度即可看出游戏难度。这里需要注意的地方：

1. 如果当前剩余搜索深度不足玩家总人数，则根据上述假设，可以认为在剩下的搜索中，玩家的决策将互相不影响。因此仅需要考虑玩家的最大收益分支，并不断深入即可，无需搜索所有分支。
2. 同极大极小策略，对搜索树从下向上进行决策，认为所有玩家会选择对其最有利的分支，其余分支数据即可抛弃。
3. 若搜索过程中游戏已经结束，为保证一致性，此处采用了奖励分数策略，及所有的搜索过程每早完成一步，即可获得对应奖励分数，以此鼓励尽早完成游戏。
4. 当搜索得分相同时，采用随机策略保证均等选取。

## 时间消耗测试

由于搜索过程中最后一回合仅需要搜索单一最大分支，因此此部分复杂度近似正比于玩家总人数（不超过6人）。而前面搜索的复杂度将呈指数上升。

不妨假设任意一步棋的走法有n种，则搜索深度为p+k时（p为游戏总人数），复杂度近似为$$ n^k \times (pn)=O(p \times n^{k+1}) $$

因此可以看到，搜索深度相对人数有着更加重要的影响。因此设置1~4级分别对应(p+0)~(p+3)层搜索深度。对应的一次尝试结果如下：

- 测试玩家：1号玩家（搜索深度3+1），3号玩家（搜索深度3+2），5号玩家（搜索深度3+3）
- 游戏模式：隔一子跳
- 开始时间：8:07:59
- 结束时间：8:37:48
- 全部耗时：~30min
- 对战结果：1号玩家：47步，3号玩家：48步，5号玩家：36步

这30min的绝大部分均被5号玩家消耗，可大致看出其搜索耗时（约1min/步）。因此正常情况下，选用1~3级对应的AI可以保证在至多几秒内返回运算结果。
